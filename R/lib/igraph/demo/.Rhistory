pause <- function() {}
### A modular graph has dense subgraphs
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
perfect <- c(rep(1,10), rep(2,10), rep(3,10))
perfect
pause()
### Plot it with community (=component) colors
plot(mod, vertex.color=perfect, layout=layout_with_fr)
### A modular graph has dense subgraphs
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
pause <- function() {}
### A modular graph has dense subgraphs
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
library("igraph")
### A modular graph has dense subgraphs
mod <- make_full_graph(10) %du% make_full_graph(10) %du% make_full_graph(10)
perfect <- c(rep(1,10), rep(2,10), rep(3,10))
perfect
pause()
### Plot it with community (=component) colors
plot(mod, vertex.color=perfect, layout=layout_with_fr)
pause()
### Modularity of the perfect division
modularity(mod, perfect)
pause()
### Modularity of the trivial partition, quite bad
modularity(mod, rep(1, 30))
pause()
### Modularity of a good partition with two communities
modularity(mod, c(rep(1, 10), rep(2,20)))
pause()
### A real little network, Zachary's karate club data
karate <- make_graph("Zachary")
karate$layout <- layout_with_kk(karate, niter=1000)
pause()
### Greedy algorithm
fc <- cluster_fast_greedy(karate)
memb <- membership(fc)
plot(karate, vertex.color=memb)
pause()
### Greedy algorithm, easier plotting
plot(fc, karate)
pause()
### Spinglass algorithm, create a hierarchical network
pref.mat <- matrix(0, 16, 16)
pref.mat[1:4,1:4] <- pref.mat[5:8,5:8] <-
pref.mat[9:12,9:12] <- pref.mat[13:16,13:16] <- 7.5/127
pref.mat[ pref.mat==0 ] <- 5/(3*128)
diag(pref.mat) <- diag(pref.mat) + 10/31
pause()
### Create the network with the given vertex preferences
G <- sample_pref(128*4, types=16, pref.matrix=pref.mat)
pause()
### Run spinglass community detection with two gamma parameters
sc1 <- cluster_spinglass(G, spins=4, gamma=1.0)
sc2.2 <- cluster_spinglass(G, spins=16, gamma=2.2)
pause()
### Plot the adjacency matrix, use the Matrix package if available
if (require(Matrix)) {
myimage <- function(...) image(Matrix(...))
} else {
myimage <- image
}
A <- as_adj(G)
myimage(A)
