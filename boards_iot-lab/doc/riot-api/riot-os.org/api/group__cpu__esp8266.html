<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from riot-os.org/api/group__cpu__esp8266.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 23 May 2019 16:31:48 GMT -->
<head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>ESP8266 / ESP8285</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org/"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right hidden-sm hidden-xs">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cpu__esp8266.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">ESP8266 / ESP8285<div class="ingroups"><a class="el" href="group__cpu.html">CPU</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>RIOT-OS port for Espressif's ESP8266 / ESP8285 MCUs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>RIOT-OS port for Espressif's ESP8266 / ESP8285 MCUs. </p>
<h1><a class="anchor" id="esp8266_riot"></a>
RIOT-OS on ESP8266 and ESP8285 boards</h1>
<h2><a class="anchor" id="esp8266_toc"></a> Table of Contents </h2>
<ol type="1">
<li><a href="#esp8266_overview">Overview</a></li>
<li><a href="#esp8266_short_configuration_reference">Short Configuration Reference</a></li>
<li><a href="#esp8266_mcu_esp8266">MCU ESP8266</a><ol type="a">
<li><a href="#esp8266_features">Features of ESP8266</a></li>
<li><a href="#esp8266_supported_features">Features Supported by RIOT-OS</a></li>
</ol>
</li>
<li><a href="#esp8266_toolchain">Toolchain</a><ol type="a">
<li><a href="#esp8266_riot_docker_toolchain">RIOT Docker Toolchain (riotdocker)</a></li>
<li><a href="#esp8266_precompiled_toolchain">Precompiled Toolchain</a></li>
<li><a href="#esp8266_manual_toolchain_installation">Manual Toolchain Installation</a></li>
</ol>
</li>
<li><a href="#esp8266_flashing_the_device">Flashing the Device</a><ol type="a">
<li><a href="#esp8266_toolchain_usage">Toolchain Usage</a></li>
<li><a href="#esp8266_compile_options">Compile Options</a></li>
<li><a href="#esp8266_flash_modes">Flash Modes</a></li>
<li><a href="#esp8266_erasing">Erasing the Device</a></li>
</ol>
</li>
<li><a href="#esp8266_peripherals">Peripherals</a><ol type="a">
<li><a href="#esp8266_gpio_pins">GPIO pins</a></li>
<li><a href="#esp8266_adc_channels">ADC Channels</a></li>
<li><a href="#esp8266_pwm_channels">PWM Channels</a></li>
<li><a href="#esp8266_i2c_interfaces">I2C Interfaces</a></li>
<li><a href="#esp8266_spi_interfaces">SPI Interfaces</a></li>
<li><a href="#esp8266_timers">Timers</a></li>
<li><a href="#esp8266_spiffs_device">SPIFFS Device</a></li>
<li><a href="#esp8266_other_peripherals">Other Peripherals</a></li>
</ol>
</li>
<li><a href="#esp8266_network_interfaces">Network Interfaces</a><ol type="a">
<li><a href="#esp8266_wifi_network_interface">WiFi Network Interface</a></li>
<li><a href="#esp8266_esp_now_network_interface">ESP-NOW Network Interface</a></li>
</ol>
</li>
<li><a href="#esp8266_preconfigured_devices">Preconfigured Devices</a><ol type="a">
<li><a href="#esp8266_network_devices">Network Devices</a></li>
<li><a href="#esp8266_sd_card_device">SD-Card Device</a></li>
</ol>
</li>
<li><a href="#esp8266_application_specific_configurations">Application-Specific Configurations</a><ol type="a">
<li><a href="#esp8266_application_specific_board_configuration">Application-Specific Board Configuration</a></li>
<li><a href="#esp8266_application_specific_driver_configuration">Application-Specific Driver Configuration</a></li>
</ol>
</li>
<li><a href="#esp8266_sdk_task_handling">SDK Task Handling</a></li>
<li><a href="#esp8266_qemu_mode_and_gdb">QEMU Mode and GDB</a></li>
</ol>
<h1><a class="anchor" id="esp8266_overview"></a> Overview  &#160;&#160; [<a href="#esp8266_toc">TOC</a>]</h1>
<p>There are two implementations that can be used:</p>
<ul>
<li>the <b>SDK version</b> which is realized on top of an SDK (<em>esp-open-sdk</em> or ESP8266_NONOS_SDK*) and</li>
<li>the <b>non-SDK version</b> which is realized without the SDK.</li>
</ul>
<p>The non-SDK version produces a much smaller code size than the SDK version and is more efficient in execution because it does not need to run additional SDK functions to keep the SDK system alive.</p>
<p>The <b>non-SDK version</b> is probably the <b>best choice if you do not need the built-in WiFi module</b>, for example, when you plan to connect an IEEE 802.15.4 radio module to the MCU for communication.</p>
<p>By <b>default</b>, the <b>non-SDK version</b> is compiled. To compile the SDK version, enable module <code>esp_wifi</code>, for example, at the make command line:</p>
<div class="fragment"><div class="line">USEMODULE=esp_sdk make flash BOARD=esp8266-esp-12x -C tests/shell ...</div></div><!-- fragment --><p>The SDK version is compiled automatically if one of the modules <code>esp_wifi</code>, <code>esp_now</code> or <code>esp_sw_timers</code> is enabled.</p>
<p>For more information about the make command variables, see section <a href="#esp8266_compile_options">Compile Options</a>.</p>
<h1><a class="anchor" id="esp8266_short_configuration_reference"></a> Short Configuration Reference  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>The following table gives a short reference of all board configuration parameters used by the ESP8266 port in alphabetical order.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Short Description </th><th>Type*  </th></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C0_SPEED</a></td><td>Bus speed of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C0_SCL</a> </td><td>GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C0_SDA</a> </td><td>GPIO used as SCL for I2C_DEV(0 </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_pwm_channels">PWM0_GPIOS</a> </td><td>GPIOs that can be used at channels of <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_spi_interfaces">SPI0_CS0</a> </td><td>GPIO used as default CS for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>o </td></tr>
</table>
</center><p><b>Type:</b> m - mandatory, o - optional# <a class="anchor" id="esp8266_mcu_esp8266"></a> MCU ESP8266  &#160;[<a href="#esp8266_toc">TOC</a>]</p>
<p>The following table gives a short reference in alphabetical order of modules that can be enabled/disabled by board configurations and/or application's makefile using <code>USEMODULE</code> and <code>DISABLE_MODULE</code>.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Module </th><th>Default </th><th>Short description  </th></tr>
<tr>
<td><a href="#esp8266_qemu_mode_and_gdb">esp_gdb</a> </td><td>not used </td><td>Enable the compilation with debug information for debugging. </td></tr>
<tr>
<td><a href="#esp8266_esp_now_network_interface">esp_now</a> </td><td>not used </td><td>Enable the ESP-NOW network device, implies the module <code>esp_sdk</code>. </td></tr>
<tr>
<td><a href="#esp8266_sdk_task_handling">esp_sdk</a> </td><td>not used </td><td>Enable the SDK version. </td></tr>
<tr>
<td><a href="#esp8266_spiffs_device">esp_spiffs</a> </td><td>not used </td><td>Enable the SPIFFS drive in on-board flash memory. </td></tr>
<tr>
<td><a href="#esp8266_timers">esp_sw_timer</a> </td><td>not used </td><td>Enable software timer implementation, implies the module <code>esp_sdk</code>. </td></tr>
<tr>
<td><a href="#esp8266_wifi_network_interface">esp_wifi</a> </td><td>not used </td><td>Enable the built-in WiFi module as <code>netdev</code> network device, implies the module <code>esp_sdk</code>. </td></tr>
</table>
</center><p>ESP8266 is a low-cost, ultra-low-power, single-core SoCs with an integrated WiFi module from Espressif Systems. The processor core is based on the Tensilica Xtensa Diamond Standard 106Micro 32-bit Controller Processor Core, which Espressif calls L106. The key features of ESP8266 are:</p>
<h2><a class="anchor" id="esp8266_features"></a> Features of ESP8266  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The key features of ESP8266 are:</p>
<center></center><center><table class="doxtable">
<tr>
<th>MCU </th><th>ESP8266EX  </th></tr>
<tr>
<td>Vendor </td><td>Espressif </td></tr>
<tr>
<td>Cores </td><td>1 x Tensilica Xtensa LX106 </td></tr>
<tr>
<td>FPU </td><td>no </td></tr>
<tr>
<td>RAM </td><td>80 kByte user-data RAM <br />
 32 kByte instruction RAM <br />
 32 kByte instruction cache <br />
 16 kByte EST system-data RAM </td></tr>
<tr>
<td>Flash </td><td>512 kByte ... 16 MByte </td></tr>
<tr>
<td>Frequency </td><td>80 MHz or 160 MHz </td></tr>
<tr>
<td>Power Consumption </td><td>70 mA in normal operating mode <br />
 20 uA in deep sleep mode </td></tr>
<tr>
<td>Timers </td><td>1 x 32 bit </td></tr>
<tr>
<td>ADCs </td><td>1 x 10 bit (1 channel) </td></tr>
<tr>
<td>GPIOs </td><td>16 </td></tr>
<tr>
<td>I2Cs </td><td>2 (software implementation) </td></tr>
<tr>
<td>SPIs </td><td>2 </td></tr>
<tr>
<td>UARTs </td><td>1 (console) + 1 transmit-only </td></tr>
<tr>
<td>WiFi </td><td>IEEE 802.11 b/g/n built in </td></tr>
<tr>
<td>Vcc </td><td>2.5 - 3.6 V </td></tr>
<tr>
<td>Datasheet </td><td><a href="https://www.espressif.com/sites/default/files/documentation/0a-esp8266ex_datasheet_en.pdf">Datasheet</a> </td></tr>
<tr>
<td>Technical Reference </td><td><a href="https://www.espressif.com/sites/default/files/documentation/esp8266-technical_reference_en.pdf">Technical Reference</a> </td></tr>
</table>
</center><p><br />
</p>
<dl class="section note"><dt>Note</dt><dd>ESP8285 is simply an ESP8266 SoC with 1 MB built-in flash. Therefore, the documentation also applies to the SoC ESP8285, even if only the ESP8266 SoC is described below.</dd></dl>
<h2><a class="anchor" id="esp8266_supported_features"></a> Features Supported by RIOT-OS  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The RIOT-OS for ESP8266 SoCs supports the following features at the moment:</p>
<ul>
<li>I2C interfaces</li>
<li>SPI interfaces</li>
<li>UART interfaces</li>
<li>CPU ID access</li>
<li>ADC channel</li>
<li>PWM channels</li>
<li>SPI Flash Drive (MTD with SPIFFS and VFS)</li>
<li>Hardware number generator</li>
<li>Hardware timer devices</li>
<li>ESP-NOW netdev interface</li>
</ul>
<h1><a class="anchor" id="esp8266_toolchain"></a> Toolchain &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>To compile RIOT for The ESP8266 SoC, the following software components are required:</p>
<ul>
<li><b>esp-open-sdk</b> which includes the <b>Xtensa GCC</b> compiler toolchain, the hardware abstraction library <b>libhal</b> for Xtensa LX106, and the flash programmer tool <b><code>esptool.py</code></b></li>
<li><b>newlib-c</b> library for Xtensa (esp-open-rtos version)</li>
<li><b>SDK (optional)</b>, either as part of <b><code>esp-open-sdk</code></b> or the <b><code>ESP8266_NONOS_SDK</code></b></li>
</ul>
<p>You have the following options to install the Toolchain:</p>
<ul>
<li><b><code>riotdocker</code></b> image and <b><code>esptool.py</code></b>, see section <a href="#esp8266_riot_docker_toolchain">RIOT Docker Toolchain (riotdocker)</a></li>
<li><b>precompiled toolchain</b> installation from GIT, see section <a href="#esp8266_toolchain_installation">Precompiled Toolchain</a></li>
<li><b>manual installation</b>, see section <a href="#esp8266_manual_toolchain_installation">Manual Toolchain Installation</a></li>
</ul>
<h2><a class="anchor" id="esp8266_riot_docker_toolchain"></a> RIOT Docker Toolchain (riotdocker)  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The easiest way to use the toolchain is Docker.</p>
<h3><a class="anchor" id="esp8266_preparing_the_environment"></a> Preparing the Environment  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>Using RIOT Docker requires at least the following software:</p>
<ul>
<li><b><code>Docker</code></b> container virtualization software</li>
<li>RIOT Docker (<b><code>riotdocker</code></b>) image</li>
<li>flasher tool <b><code>esptool.py</code></b></li>
</ul>
<p>For information about installing Docker on your host, refer to the appropriate manuals for your operating system. For example, the easiest way to install Docker on the Ubuntu/Debian system is: </p><div class="fragment"><div class="line">sudo apt-<span class="keyword">get</span> install docker.io</div></div><!-- fragment --><p>The ESP Flasher tool <b><code>esptool.py</code></b> is available at <a href="https://github.com/espressif/esptool">GitHub</a>. To install the tool, either Python 2.7 or Python 3.4 or later must be installed. The latest stable version of <code>esptool.py</code> can be installed with <code>pip</code>: </p><div class="fragment"><div class="line">pip install esptool</div></div><!-- fragment --><p><b><code>esptool.py</code></b> depends on <code>pySerial</code> which can be installed either using <code>pip</code></p>
<div class="fragment"><div class="line">pip install pyserial</div></div><!-- fragment --><p> or the package manager of your OS, for example on Debian/Ubuntu systems: </p><div class="fragment"><div class="line">apt-<span class="keyword">get</span> install pyserial</div></div><!-- fragment --><p> For more information on <code>esptool.py</code>, please refer the <a href="https://github.com/espressif/esptool">git repository</a></p>
<p>Please make sure that <code>esptool.py</code> is in your <code>PATH</code> variable.</p>
<h3><a class="anchor" id="esp8266_generating_docker_image"></a> Generating a riotdocker Image  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>A <code>riotdocker</code> fork that only installs the <code>RIOT-Xtensa-ESP8266-toolchain</code> is available at <a href="https://github.com/gschorcht/riotdocker-Xtensa-ESP.git">GitHub</a>. After cloning this git repository, you can use branch <code>esp8266_only</code> to generate a Docker image with a size of "only" 990 MByte:</p>
<div class="fragment"><div class="line">git clone https:<span class="comment">//github.com/gschorcht/riotdocker-Xtensa-ESP.git</span></div><div class="line">cd riotdocker-Xtensa-ESP</div><div class="line">git checkout esp8266_only</div><div class="line">docker build -t riotbuild .</div></div><!-- fragment --><p> A <code>riotdocker</code> version that contains the toolchains for all different RIOT platforms can be found at <a href="https://github.com/RIOT-OS/riotdocker">GitHub</a>. However, the Docker image generated from the this Docker file has a size of about 1.5 GByte.</p>
<p>Once a Docker image has been created, it can be started with the following commands while in the RIOT root directory: </p><div class="fragment"><div class="line">cd /path/to/RIOT</div><div class="line">docker run -i -t --privileged -v /dev:/dev -u $UID -v $(pwd):/data/riotbuild riotbuild</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>RIOT's root directory <code>/path/to/RIOT</code> becomes visible as the home directory of the <code>riotbuild</code> user in the Docker image. That is, the output of compilations performed in RIOT Docker is also accessible on the host system.</dd></dl>
<p>Please refer the <a href="https://github.com/RIOT-OS/RIOT/wiki/Use-Docker-to-build-RIOT">RIOT wiki</a> on how to use the Docker image to compile RIOT OS.</p>
<h3><a class="anchor" id="esp8266_using_existing_docker_image"></a> Using an Existing riotdocker Image  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>Alternatively, an existing Docker image from Docker Hub can be used. You can either pull and start the <a href="https://hub.docker.com/r/schorcht/riotbuild_esp8266">schorcht/riotbuild_esp8266</a> Docker image which only contains the <code>RIOT-Xtensa-ESP8266-toolchain</code> using </p><div class="fragment"><div class="line">cd /path/to/RIOT</div><div class="line">docker run -i -t --privileged -v /dev:/dev -u $UID -v $(pwd):/data/riotbuild schorcht/riotbuild_esp8266</div></div><!-- fragment --><p> or the <a href="https://hub.docker.com/r/riot/riotbuild/">riot/riotbuild</a> Docker image (size is about 1.5 GB) which contains the toolchains for all platforms using </p><div class="fragment"><div class="line">cd /path/to/RIOT</div><div class="line">docker run -i -t --privileged -v /dev:/dev -u $UID -v $(pwd):/data/riotbuild <a class="code" href="namespaceriot.html">riot</a>/riotbuild</div></div><!-- fragment --> <h3><a class="anchor" id="esp8266_flashing_using_docker"></a> Make Process with Docker Image  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>Using Docker, the make process consists of the following two steps:</p>
<ol type="1">
<li><b>making</b> the RIOT binary <b>within a RIOT Docker image</b></li>
<li><b>flashing</b> the RIOT binary using a flasher program <b>on the host system</b></li>
</ol>
<p>Once the RIOT Docker image has been started from RIOT's root directory, a RIOT application can be compiled inside the Docker using the make command as usual, for example:</p>
<div class="fragment"><div class="line">make BOARD=esp8266-esp-12x -C tests/shell ...</div></div><!-- fragment --><p> This will generate a RIOT binary in ELF format.</p>
<dl class="section note"><dt>Note</dt><dd>You can't use the <code>flash</code> target inside the Docker image.</dd></dl>
<p>The RIOT binary has to be flash outside docker on the host system. Since the Docker image was stared while in RIOT's root directory, the output of the compilations is also accessible on the host system. On the host system, the <code>flash-only</code> target can then be used to flash the binary. </p><div class="fragment"><div class="line">make flash-only BOARD=esp8266-esp-12x -C tests/shell</div></div><!-- fragment --><h2><a class="anchor" id="esp8266_precompiled_toolchain"></a> Precompiled Toolchain  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>You can get a precompiled version of the whole toolchain from the GIT repository <a href="https://github.com/gschorcht/RIOT-Xtensa-ESP8266-toolchain">RIOT-Xtensa-ESP8266-toolchain</a>. This repository contains the precompiled toolchain including all libraries that are necessary to compile RIOT-OS for ESP8266.</p>
<dl class="section note"><dt>Note</dt><dd>To use the precompiled toolchain the following packages (Debian/Ubuntu) have to be installed:<br />
 <code>cppcheck</code> <code>coccinelle</code> <code>curl</code> <code>doxygen</code> <code>git</code> <code>graphviz</code> <code>make</code> <code>pcregrep</code> <code>python</code> <code>python-serial</code> <code>python3</code> <code>python3-flake8</code> <code>unzip</code> <code>wget</code></dd></dl>
<p>To install the toolchain use the following commands: </p><div class="fragment"><div class="line">cd /opt</div><div class="line">sudo git clone https:<span class="comment">//github.com/gschorcht/RIOT-Xtensa-ESP8266-toolchain.git esp</span></div></div><!-- fragment --><p> After the installation, all components of the toolchain are installed in directory <code>/opt/esp</code>. Of course, you can use any other location for the installation.</p>
<p>To use the toolchain, you have to add the path of the binaries to your <code>PATH</code> variable according to your toolchain location</p>
<div class="fragment"><div class="line">export PATH=$PATH:/path/to/toolchain/esp-open-sdk/xtensa-lx106-elf/bin</div></div><!-- fragment --><p> where <code>/path/to/toolchain/</code> is the directory you selected for the installation of the toolchain. For the default installation in <code>/opt/esp</code> this would be: </p><div class="fragment"><div class="line">export PATH=$PATH:/opt/esp/esp-open-sdk/xtensa-lx106-elf/bin</div></div><!-- fragment --><p>Furthermore, you have to set variables <code>ESP8266_SDK_DIR</code> and <code>ESP8266_NEWLIB_DIR</code> according to the location of the toolchain. </p><div class="fragment"><div class="line">export ESP8266_SDK_DIR=/path/to/toolchain/esp-open-sdk/sdk</div><div class="line">export ESP8266_NEWLIB_DIR=/path/to/toolchain/newlib-xtensa</div></div><!-- fragment --><p> If you have used <code>/opt/esp</code> as installation directory, it is not necessary to set these variables since makefiles use them as default directories.</p>
<h2><a class="anchor" id="esp8266_manual_toolchain_installation"></a> Manual Toolchain Installation  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The most difficult way to install the toolchain is the manual installation of required components as described below.</p>
<dl class="section note"><dt>Note</dt><dd>Manual toolchain installation requires that the following packages (Debian/Ubuntu) are installed: <code>autoconf</code> <code>automake</code> <code>bash</code> <code>bison</code> <code>build-essential</code> <code>bzip2</code> <code>coccinelle</code> <code>cppcheck</code> <code>curl</code> <code>doxygen</code> <code>g++</code> <code>gperf</code> <code>gawk</code> <code>gcc</code> <code>git</code> <code>graphviz</code> <code>help2man</code> <code>flex</code> <code>libexpat-dev</code> <code>libtool</code> <code>libtool-bin</code> <code>make</code> <code>ncurses-dev</code> <code>pcregrep</code> <code>python</code> <code>python-dev</code> <code>python-serial</code> <code>python3</code> <code>python3-flake8</code> <code>sed</code> <code>texinfo</code> <code>unrar-free</code> <code>unzip wget</code></dd></dl>
<h3><a class="anchor" id="esp8266_installation_of_esp_open_sdk"></a> Installation of esp-open-sdk  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>esp-open-sdk is directly installed inside its source directory. Therefore, change directly to the target directory of the toolchain to build it.</p>
<div class="fragment"><div class="line">cd /path/to/esp</div><div class="line">git clone --recursive https:<span class="comment">//github.com/pfalcon/esp-open-sdk.git</span></div><div class="line">cd esp-open-sdk</div><div class="line">export ESP_OPEN_SDK_DIR=$PWD</div></div><!-- fragment --><p>If you plan to use the SDK version of the RIOT port and to use the SDK as part of esp-open-sdk, simply build its standalone version.</p>
<div class="fragment"><div class="line">make STANDALONE=y</div></div><!-- fragment --><p>If you only plan to use the non-SDK version of the RIOT port or if you want to use one of Espressif's original SDKs, it is enough to build the toolchain.</p>
<div class="fragment"><div class="line">make toolchain esptool libhal STANDALONE=n</div></div><!-- fragment --><p>Once compilation has been finished, the toolchain is available in <code>$PWD/xtensa-lx106-elf/bin</code>. To use it, set the <code>PATH</code> variable accordingly.</p>
<div class="fragment"><div class="line">export PATH=$ESP_OPEN_SDK_DIR/xtensa-lx106-elf/bin:$PATH</div></div><!-- fragment --><p>If you have compiled the standalone version of esp-open-sdk and you plan to use this SDK version, set additionally the <code>ESP8266_SDK_DIR</code> variable.</p>
<div class="fragment"><div class="line">export ESP8266_SDK_DIR=$ESP_OPEN_SDK_DIR/sdk</div></div><!-- fragment --><h3><a class="anchor" id="esp8266_installation_of_newlib-c"></a> Installation of newlib-c  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>First, set the target directory for the installation.</p>
<div class="fragment"><div class="line">export ESP8266_NEWLIB_DIR=/path/to/esp/newlib-xtensa</div></div><!-- fragment --><p>Please take care, to use the newlib-c version that was modified for esp-open-rtos since it includes <code>stdatomic.h</code>.</p>
<div class="fragment"><div class="line">cd /my/source/dir</div><div class="line">git clone https:<span class="comment">//github.com/ourairquality/newlib.git</span></div></div><!-- fragment --><p>Once you have cloned the GIT repository, build and install it with following commands. </p><div class="fragment"><div class="line">cd newlib</div><div class="line">./configure --prefix=$ESP8266_NEWLIB_DIR --with-newlib --enable-multilib --disable-newlib-io-c99-formats --enable-newlib-supplied-syscalls --enable-target-optspace --program-transform-name=<span class="stringliteral">&quot;s&amp;^&amp;xtensa-lx106-elf-&amp;&quot;</span> --disable-option-checking --with-target-subdir=xtensa-lx106-elf --target=xtensa-lx106-elf --enable-newlib-nano-formatted-io --enable-newlib-reent-small</div><div class="line">make</div><div class="line">make install</div></div><!-- fragment --><h3><a class="anchor" id="esp8266_installation_of_espressif_original_sdk"></a> Installation of Espressif original SDK (optional)  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>If you plan to use the SDK version of the RIOT port and if you want to use one of Espressif's original SDKs, you have to install it.</p>
<p>First, download the <em>ESP8266_NONOS_SDK</em> version 2.1.0 from the <a href="https://github.com/espressif/ESP8266_NONOS_SDK/releases/tag/v2.1.0">Espressif web site</a>. Probably other version might also work. However, RIOT port is tested with version 2.1.0.</p>
<p>Once you have downloaded it, you can install it with following commands.</p>
<div class="fragment"><div class="line">cd /path/to/esp</div><div class="line">tar xvfz /downloads/ESP8266_NONOS_SDK-2.1.0.tar.gz</div></div><!-- fragment --><p>To use the installed SDK, set variable <code>ESP8266_SDK_DIR</code> accordingly.</p>
<div class="fragment"><div class="line">export ESP8266_SDK_DIR=/path/to/esp/ESP8266_NONOS_SDK-2.1.0</div></div><!-- fragment --><h1><a class="anchor" id="esp8266_flashing_the_device"></a> Flashing the Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<h2><a class="anchor" id="esp8266_toolchain_usage"></a> Toolchain Usage  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Once you have installed all required components, you should have the following directories.</p>
<div class="fragment"><div class="line">/path/to/esp/esp-open-sdk</div><div class="line">/path/to/esp/newlib-xtensa</div><div class="line">/path/to/esp/ESP8266_NONOS_SDK-2.1.0 (optional)</div></div><!-- fragment --><p>To use the toolchain and optionally the SDK, please check that your environment variables are set correctly to</p>
<div class="fragment"><div class="line">export PATH=/path/to/esp/esp-open-sdk/xtensa-lx106-elf/bin:$PATH</div><div class="line">export ESP8266_NEWLIB_DIR=/path/to/esp/newlib-xtensa</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">export ESP8266_SDK_DIR=/path/to/esp/esp-open-sdk/sdk</div></div><!-- fragment --><p> or</p>
<div class="fragment"><div class="line">export ESP8266_SDK_DIR=/path/to/esp/ESP8266_NONOS_SDK-2.1.0</div></div><!-- fragment --><h2><a class="anchor" id="esp8266_compile_options"></a> Compile Options  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The compilation process can be controlled by a number of variables for the make command:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Option </th><th>Values </th><th>Default </th><th>Description  </th></tr>
<tr>
<td>ENABLE_GDB </td><td>0, 1 </td><td>0 </td><td>Enable compilation with debug information for debugging with QEMU (<code>QEMU=1</code>), see section <a href="#esp8266_qemu_mode_and_gdb">QEMU Mode and GDB</a> </td></tr>
<tr>
<td>FLASH_MODE </td><td>dout, dio, qout, qio </td><td>dout </td><td>Set the flash mode, please take care with your module, see section <a href="#esp8266_flash_modes">Flash Modes</a> </td></tr>
<tr>
<td>PORT </td><td>/dev/ttyUSBx </td><td>/dev/* </td><td>Set the USB port for flashing the firmware </td></tr>
<tr>
<td>QEMU </td><td>0, 1 </td><td>0 </td><td>Generate an image for QEMU, see section <a href="#esp8266_qemu_mode_and_gdb">QEMU Mode and GDB</a>. </td></tr>
<tr>
<td>USE_SDK </td><td>0, 1 </td><td>0 </td><td>Compile the SDK version (<code>USE_SDK=1</code>), see section <a href="#esp8266_sdk_task_handling">SDK Task Handling</a> </td></tr>
</table>
</center><p><br />
</p>
<p>Optional features of ESP8266 can be enabled by <code>USEMODULE</code> definitions in the makefile of the application. These are:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Module </th><th>Description  </th></tr>
<tr>
<td><a href="#esp8266_qemu_mode_and_gdb">esp_gdb</a> </td><td>Enable the compilation with debug information, which is equivalent to using <code>ENABLE_GDB=1</code>. </td></tr>
<tr>
<td><a href="#esp8266_esp_now_network_interface">esp_now</a> </td><td>Enable the built-in WiFi module with the ESP-NOW protocol as <code>netdev</code> network device, implies the setting module <code>esp_sdk</code>. </td></tr>
<tr>
<td><a href="#esp8266_sdk_task_handling">esp_sdk</a> </td><td>Enable the SDK version, which is equivalent to using <code>USE_SDK=1</code>. </td></tr>
<tr>
<td><a href="#esp8266_spiffs_device">esp_spiffs</a> </td><td>Enable the SPIFFS drive in on-board flash memory </td></tr>
<tr>
<td><a href="#esp8266_timers">esp_sw_timer</a> </td><td>Enable software timer implementation, implies the setting module <code>esp_sdk</code>. </td></tr>
<tr>
<td><a href="#esp8266_wifi_network_interface">esp_wifi</a> </td><td>Use the built-in WiFi module as <code>netdev</code> network device, implies the setting module <code>esp_sdk</code>. </td></tr>
</table>
</center><p><br />
</p>
<p>For example, to activate the SPIFFS drive in on-board flash memory, the makefile of application has simply to add the <code>esp_spiffs</code> module to <code>USEMODULE</code> make variable: </p><div class="fragment"><div class="line">USEMODULE += esp_spiffs</div></div><!-- fragment --><p>Modules can also be activated temporarily at the command line when calling the make command: </p><div class="fragment"><div class="line">USEMODULE=<span class="stringliteral">&quot;esp_spiffs&quot;</span> make BOARD=...</div></div><!-- fragment --><h2><a class="anchor" id="esp8266_flash_modes"></a> Flash Modes  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The <code>FLASH_MODE</code> make command variable determines the mode that is used for flash access in normal operation.</p>
<p>The flash mode determines whether 2 data lines (<code>dio</code> and <code>dout</code>) or 4 data lines (<code>qio</code> and <code>qout</code>) for addressing and data access. For each data line, one GPIO is required. Therefore, using <code>qio</code> or <code>qout</code> increases the performance of SPI Flash data transfers, but uses two additional GPIOs (GPIO9 and GPIO10). That is, in this flash modes these GPIOs are not available for other purposes. If you can live with lower flash data transfer rates, you should always use <code>dio</code> or <code>dout</code> to keep GPIO9 and GPIO10 free for other purposes.</p>
<p>For more information about these flash modes, refer the documentation of <a href="https://github.com/espressif/esptool/wiki/SPI-Flash-Modes">esptool.py</a>.</p>
<dl class="section note"><dt>Note</dt><dd>While ESP8266 modules can be flashed with <code>qio</code>, <code>qout</code>, <code>dio</code> and <code>dout</code>, ESP8285 modules have to be always flashed in <code>dout</code> mode. The default flash mode is <code>dout</code>.</dd></dl>
<h2><a class="anchor" id="esp8266_erasing"></a> Erasing the Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The flash memory of ESP8266 can be erased completely with following command: </p><div class="fragment"><div class="line">esptool.py erase_flash</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>After deleting the flash, the default init data must be rewritten. In a non-SDK version, this will happen automatically when RIOT is started for the first time after flashing the image. In the SDK version, this must be done explicitly. There are two possible approaches to rewriting standard initialization data:</dd></dl>
<ul>
<li>Flash and start a non-SDK image before the SDK version is flashed.</li>
<li>Use the esptool.py file to update the default init data as following.</li>
</ul>
<div class="fragment"><div class="line">esptool.py write_flash &lt;address&gt; $RIOTBASE/cpu/esp8266/bin/esp_init_data_default.bin</div></div><!-- fragment --><p>where <code>address</code> depends on ESP8266 chip version.</p>
<table class="doxtable">
<tr>
<th>Chip version </th><th><code>address</code> </th><th>Module examples  </th></tr>
<tr>
<td>512 kByte </td><td>0x07c000 </td><td>ESP-01, ESP-03, ESP-07, etc. </td></tr>
<tr>
<td>1 MByte </td><td>0x0fc000 </td><td>ESP8285-based modules like Wemos D1 mini lite, PSF-A85, some ESP-01, ESP-03 etc. </td></tr>
<tr>
<td>2 MByte </td><td>0x1fc000 </td><td></td></tr>
<tr>
<td>4 MByte </td><td>0x3fc000 </td><td>ESP-12E, NodeMCU devkit 1.0, WeMos D1 mini </td></tr>
<tr>
<td>8 MByte </td><td>0x7fc000 </td><td></td></tr>
<tr>
<td>16 MByte </td><td>0xffc000 </td><td>WeMos D1 mini pro (USE 0x07c000!) </td></tr>
</table>
<h1><a class="anchor" id="esp8266_peripherals"></a> Peripherals  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<h2><a class="anchor" id="esp8266_gpio_pins"></a> GPIO pins  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 has 17 GPIO pins, which are all digital pins. Some of them can not be used at all or have bootstrapping capabilities and are therefore not available on all boards.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Pin </th><th>Remarks  </th></tr>
<tr>
<td>GPIO0 </td><td>usually pulled up </td></tr>
<tr>
<td>GPIO1 </td><td>UART TxD </td></tr>
<tr>
<td>GPIO2 </td><td>usually pulled up </td></tr>
<tr>
<td>GPIO3 </td><td>UART RxD </td></tr>
<tr>
<td>GPIO4 </td><td></td></tr>
<tr>
<td>GPIO5 </td><td></td></tr>
<tr>
<td>GPIO6 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO7 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO8 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO9 </td><td>Flash SPI in <code>qout</code> and <code>qio</code> mode, see section <a href="#esp8266_flash_modes">Flash Modes</a> </td></tr>
<tr>
<td>GPIO10 </td><td>Flash SPI in <code>qout</code> and <code>qio</code> mode, see section <a href="#esp8266_flash_modes">Flash Modes</a> </td></tr>
<tr>
<td>GPIO11 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO12 </td><td></td></tr>
<tr>
<td>GPIO13 </td><td></td></tr>
<tr>
<td>GPIO14 </td><td></td></tr>
<tr>
<td>GPIO15 </td><td>usually pulled down </td></tr>
<tr>
<td>GPIO16 </td><td>RTC pin and wake up signal in deep sleep mode </td></tr>
</table>
</center><p>GPIO0, GPIO2, and GPIO15 are bootstrapping pins which are used to boot ESP8266 in different modes:</p>
<center></center><center><table class="doxtable">
<tr>
<th align="center">GPIO0 </th><th align="center">GPIO2 </th><th align="center">GPIO15 (MTDO) </th><th align="left">Mode  </th></tr>
<tr>
<td align="center">1 </td><td align="center">X </td><td align="center">X </td><td align="left">boot in SDIO mode to start OCD </td></tr>
<tr>
<td align="center">0 </td><td align="center">0 </td><td align="center">1 </td><td align="left">boot in UART mode for flashing the firmware </td></tr>
<tr>
<td align="center">0 </td><td align="center">1 </td><td align="center">1 </td><td align="left">boot in FLASH mode to boot the firmware from flash (default mode) </td></tr>
</table>
</center><h2><a class="anchor" id="esp8266_adc_channels"></a> ADC Channels  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 has <b>one dedicated ADC</b> pin with a resolution of 10 bits. This ADC pin can measure voltages in the range of <b>0 V ... 1.1 V</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Some boards have voltage dividers to scale this range to a maximum of 3.3 V. For more information, see the hardware manual for the board.</dd></dl>
<h2><a class="anchor" id="esp8266_pwm_channels"></a> PWM Channels  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The hardware implementation of ESP8266 PWM supports only frequencies as power of two. Therefore, a <b>software implementation</b> of <b>one PWM device</b> (<code><a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a></code>) with up to <b>8 PWM channels</b> (<code>PWM_CHANNEL_NUM_MAX</code>) is used.</p>
<dl class="section note"><dt>Note</dt><dd>The minimum PWM period that can be realized with this software implementation is 10 us or 100.000 PWM clock cycles per second. Therefore, the product of frequency and resolution should not be greater than 100.000. Otherwise the frequency is scaled down automatically.</dd></dl>
<p>GPIOs that can be used as channels of the PWM device <code><a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a></code> are defined by <code>PWM0_CHANNEL_GPIOS</code>. By default, GPIOs 2, 4 and 5 are defined as PWM channels. As long as these channels are not started with function <code>pwm_set</code>, they can be used as normal GPIOs for other purposes.</p>
<p>GPIOs in <code>PWM0_CHANNEL_GPIOS</code> with a duty cycle value of 0 can be used as normal GPIOs for other purposes. GPIOs in <code>PWM0_CHANNEL_GPIOS</code> that are used for other purposes, e.g., I2C or SPI, are no longer available as PWM channels.</p>
<p>To define other GPIOs as PWM channels, just overwrite the definition of <code>PWM_CHANNEL_GPIOS</code> in an <a href="#esp8266_application_specific_board_configuration">application-specific board configuration</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#define PWM0_CHANNEL_GPIOS { GPIO12, GPIO13, GPIO14, GPIO15 }</span></div></div><!-- fragment --><h2><a class="anchor" id="esp8266_i2c_interfaces"></a> I2C Interfaces  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Since the ESP8266 does not or only partially support the I2C in hardware, I2C interfaces are realized as <b>bit-banging protocol in software</b>. The maximum usable bus speed is <code>I2C_SPEED_FAST_PLUS</code>. The maximum number of buses that can be defined is 2, <code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a></code> ... <code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(1)</a></code>.</p>
<p>The board-specific configuration of the I2C interface <b><code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a></code></b> requires the definition of</p>
<ul>
<li><b><code>I2Cn_SPEED</code></b>, the bus speed,</li>
<li><b><code>I2Cn_SCL</code></b>, the GPIO used as SCL signal, and</li>
<li><b><code>I2Cn_SDA</code></b>, the GPIO used as SDA signal,</li>
</ul>
<p>where <code>n</code> can be 0 or 1. If they are not defined, the I2C interface <code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a></code> is not used.</p>
<p>In the following example, only one I2C bus is defined:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define I2C_NUMOF      (1)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define I2C0_SPEED     I2C_SPEED_FAST</span></div><div class="line"><span class="preprocessor">#define I2C0_SDA       GPIO4</span></div><div class="line"><span class="preprocessor">#define I2C0_SCL       GPIO5</span></div></div><!-- fragment --><p> A configuration with two I2C buses would look like the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define I2C_NUMOF      (2)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define I2C0_SPEED     I2C_SPEED_FAST</span></div><div class="line"><span class="preprocessor">#define I2C0_SDA       GPIO4</span></div><div class="line"><span class="preprocessor">#define I2C0_SCL       GPIO5</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define I2C1_SPEED     I2C_SPEED_NORMAL</span></div><div class="line"><span class="preprocessor">#define I2C1_SDA       GPIO2</span></div><div class="line"><span class="preprocessor">#define I2C1_SCL       GPIO14</span></div></div><!-- fragment --><p>All these configurations can be overridden by an <a href="#esp8266_application_specific_board_configuration">application-specific board configuration</a>.</p>
<h2><a class="anchor" id="esp8266_spi_interfaces"></a> SPI Interfaces  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 provides two hardware SPI interfaces:</p>
<ul>
<li><em>FSPI</em> for flash memory access that is usually simply referred to as <em>SPI</em></li>
<li><em>HSPI</em> for peripherals</li>
</ul>
<p>Even though <em>FSPI</em> (or simply <em>SPI</em>) is a normal SPI interface, it is not possible to use it for peripherals. <b>HSPI is therefore the only usable SPI interface</b> available for peripherals as RIOT's <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a></code>.</p>
<p>The pin configuration of the <em>HSPI</em> interface is defined as shown in the following table. Only the CS signal can be configured and overridden by <a href="# esp8266_application_specific_board_configuration">application-specific card configuration</a>.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Signal of <em>HSPI</em> </th><th>Pin  </th></tr>
<tr>
<td>MISO </td><td>GPIO12 </td></tr>
<tr>
<td>MOSI </td><td>GPIO13 </td></tr>
<tr>
<td>SCK </td><td>GPIO14 </td></tr>
<tr>
<td>CS </td><td>GPIO15 </td></tr>
</table>
</center><p>When SPI is enabled using module <code>periph_spi</code>, these GPIOs cannot be used for any other purpose. The given CS pin is used when <code>spi_acquire</code> is called with <code>cs=GPIO_UNDEF</code> parameter.</p>
<p>To the default CS can be overridden as following: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SPI0_CS0_GPIO    GPIO15     </span><span class="comment">/* HSPI/SPI_DEV(0) CS default pin */</span><span class="preprocessor"></span></div></div><!-- fragment --><p>GPIOs 0, 2, 4, 5, 15, and 16 can be used as CS signal. In <code>dio</code> and <code>dout</code> flash modes (see section <a href="#esp8266_flash_modes">Flash Modes</a>), GPIOs 9 and 10 can also be used as CS signal.</p>
<h2><a class="anchor" id="esp8266_timers"></a> Timers  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>There are two timer implementations:</p>
<ul>
<li><b>hardware timer</b> implementation with <b>1 timer device</b> and only <b>1 channel</b>, the default</li>
<li><b>software timer</b> implementation with <b>1 timer device</b> and only <b>10 channels</b></li>
</ul>
<p>By default, the <b>hardware timer implementation</b> is used.</p>
<p>When the SDK version of the RIOT port (<code>USE_SDK=1</code>) is used, the <b>software timer</b> implementation is activated by using module <code>esp_sw_timer</code>.</p>
<p>The software timer uses SDK's software timers to implement the timer channels. Although these SDK timers usually have a precision of a few microseconds, they can deviate up to 500 microseconds. So if you need a timer with high accuracy, you'll need to use the hardware timer with only one timer channel.</p>
<dl class="section note"><dt>Note</dt><dd>When module <code>esp_sw_timer</code> is used, the SDK version is automatically compiled (<code>USE_SDK=1</code>).</dd></dl>
<h2><a class="anchor" id="esp8266_spiffs_device"></a> SPIFFS Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>If SPIFFS module is enabled (<code>USEMODULE += esp_spiffs</code>), the implemented MTD system drive <code>mtd0</code> for the on-board SPI flash memory is used together with modules <code>spiffs</code> and <code>vfs</code> to realize a persistent file system.</p>
<p>For this purpose, the flash memory is formatted as SPIFFS starting at the address <code>0x80000</code> (512 kByte) on first boot. All sectors up to the last 5 sectors of the flash memory are then used for the file system. With a fixed sector size of 4096 bytes, the top address of the SPIFF is <code>flash_size - 5 * 4096</code>, e.g., <code>0xfb000</code> for a flash memory of 1 MByte. The size of the SPIFF then results from: </p><div class="fragment"><div class="line">flash_size - 5 * 4096 - 512 kByte</div></div><!-- fragment --><p>Please refer file <code>$RIOTBASE/tests/unittests/test-spiffs/tests-spiffs.c</code> for more information on how to use SPIFFS and VFS together with a MTD device <code>mtd0</code> alias <code>MTD_0</code>.</p>
<h2><a class="anchor" id="esp8266_other_peripherals"></a> Other Peripherals  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The ESP8266 port of RIOT also supports</p>
<ul>
<li>one hardware number generator with 32 bit,</li>
<li>one UART interface (GPIO1 and GPIO3),</li>
<li>a CPU-ID function, and</li>
<li>power management functions.</li>
</ul>
<p>RTC is not yet implemented.</p>
<h1><a class="anchor" id="esp8266_network_interfaces"></a> Network Interfaces  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>ESP8266 provides different built-in possibilities to realize network devices:</p>
<ul>
<li><b>ESP WiFi</b>, usual AP-based infrastructure mode wireless LAN</li>
<li><b>ESP-NOW</b>, a WiFi based AP-less and connectionless peer to peer communication protocol</li>
</ul>
<p><a class="anchor" id="esp8266_wifi_network_interface"></a></p><h2><a class="anchor" id="esp8266_wifi_network_interface"></a> WiFi Network Interface  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The RIOT port for ESP8266 implements in module <code>esp_wifi</code> a <code>netdev</code> driver for the built-in WiFi interface.</p>
<dl class="section note"><dt>Note</dt><dd>Due to symbol conflicts with the <code>crypto</code> and <code>hash</code> modules of RIOT in vendor library <code>libwpa.so</code>, which is required by module <code>esp_wifi</code>, <code>esp_wifi</code> cannot be used for applications that use these modules. Therefore, module **<code>esp_wifi</code> is not automatically enabled** when module <code>netdev_default</code> is used. Instead, if necessary, the application has to add the module <code>esp_wifi</code> in the Makefile.</dd></dl>
<div class="fragment"><div class="line">USEMODULE += esp_wifi</div></div><!-- fragment --><p>Furthermore, the following configuration parameters have to be defined:</p>
<center></center><center><table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Default </th><th align="left">Description  </th></tr>
<tr>
<td align="left">ESP_WIFI_SSID </td><td align="left">"RIOT_AP" </td><td align="left">SSID of the AP to be used. </td></tr>
<tr>
<td align="left">ESP_WIFI_PASS </td><td align="left">"ThisistheRIOTporttoESP" </td><td align="left">Passphrase used for the AP as clear text (max. 64 chars). </td></tr>
<tr>
<td align="left">ESP_WIFI_STACKSIZE </td><td align="left">1536 </td><td align="left">Stack size used for the WiFi netdev driver thread. </td></tr>
</table>
</center><p>These configuration parameter definitions, as well as enabling the <code>esp_wifi</code> module, can be done either in the makefile of the project or at make command line, e.g.: </p><div class="fragment"><div class="line">USEMODULE=esp_wifi \</div><div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_WIFI_SSID=\&quot;MySSID\&quot; -DESP_WIFI_PASS=\&quot;MyPassphrase\&quot;&#39;</span> \</div><div class="line">make -C examples/gnrc_networking BOARD=...</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The Wifi network interface (module <code>esp_wifi</code>) and the <a href="#esp8266_esp_now_network_interface">ESP-NOW network interface</a> (module <code>esp_now</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW.</dd></dl>
<p><a class="anchor" id="esp8266_esp_now_network_interface"></a></p><h2><a class="anchor" id="esp8266_esp_now_network_interface"></a> ESP-NOW Network Interface  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>With ESP-NOW, the ESP8266 provides a connectionless communication technology, featuring short packet transmission. It applies the IEEE802.11 Action Vendor frame technology, along with the IE function developed by Espressif, and CCMP encryption technology, realizing a secure, connectionless communication solution.</p>
<p>The RIOT port for ESP8266 implements in module <code>esp_now</code> a <code>netdev</code> driver which uses ESP-NOW to provide a link layer interface to a meshed network of ESP8266 nodes. In this network, each node can send short packets with up to 250 data bytes to all other nodes that are visible in its range.</p>
<dl class="section note"><dt>Note</dt><dd>Due to symbol conflicts in vendor library <code>libwpa.so</code> used by the <code>esp_now</code> with RIOT's <code>crypto</code> and <code>hashes</code> modules, ESP-NOW cannot be used for application that use these modules. Therefore, the module **<code>esp_now</code> is not enabled automatically** if the <code>netdev_default</code> module is used. Instead, the application has to add the <code>esp_now</code> module in its makefile when needed.<br />
 <div class="fragment"><div class="line">USEMODULE += esp_now</div></div><!-- fragment --></dd></dl>
<p>For ESP-NOW, ESP8266 nodes are used in WiFi SoftAP + Station mode to advertise their SSID and become visible to other ESP8266 nodes. The SSID of an ESP8266 node is the concatenation of the prefix <code>RIOT_ESP_</code> with the MAC address of its SoftAP WiFi interface. The driver periodically scans all visible ESP8266 nodes.</p>
<p>The following parameters are defined for ESP-NOW nodes. These parameters can be overriden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<center></center><center><table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Default </th><th align="left">Description  </th></tr>
<tr>
<td align="left">ESP_NOW_SCAN_PERIOD </td><td align="left">10000000UL </td><td align="left">Defines the period in us at which an node scans for other nodes in its range. The default period is 10 s. </td></tr>
<tr>
<td align="left">ESP_NOW_SOFT_AP_PASS </td><td align="left">"ThisistheRIOTporttoESP" </td><td align="left">Defines the passphrase as clear text (max. 64 chars) that is used for the SoftAP interface of ESP-NOW nodes. It has to be same for all nodes in one network. </td></tr>
<tr>
<td align="left">ESP_NOW_CHANNEL </td><td align="left">6 </td><td align="left">Defines the channel that is used as the broadcast medium by all nodes together. </td></tr>
<tr>
<td align="left">ESP_NOW_KEY </td><td align="left">NULL </td><td align="left">Defines a key that is used for encrypted communication between nodes. If it is NULL, encryption is disabled. The key has to be of type <code>uint8_t[16]</code> and has to be exactly 16 bytes long. </td></tr>
<tr>
<td align="left">ESP_WIFI_STACKSIZE </td><td align="left"><a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a> </td><td align="left">Stack size used for the WiFi netdev driver thread. </td></tr>
</table>
</center><p>These configuration parameter definitions, as well as enabling the <code>esp_wifi</code> module, can be done either in the makefile of the project or at make command line, e.g.:</p>
<div class="fragment"><div class="line">USEMODULE=esp_now \</div><div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_NOW_CHANNEL=8 -DESP_NOW_SOFT_AP_PASS=\&quot;MyPassphrase\&quot;&#39;</span> \</div><div class="line">make -C examples/gnrc_networking BOARD=...</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The ESP-NOW network interface (module <code>esp_now</code>) and the <a href="#esp8266_wifi_network_interface">Wifi network interface</a> (module <code>esp_wifi</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW.</dd></dl>
<h1><a class="anchor" id="esp8266_preconfigured_devices"></a> Preconfigured Devices  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>The ESP8266 port of RIOT has been tested with several common external devices that can be connected to ESP8266 boards and are preconfigured accordingly.</p>
<h2><a class="anchor" id="esp8266_network_devices"></a> Network Devices  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>RIOT provides a number of driver modules for different types of network devices, e.g., IEEE 802.15.4 radio modules and Ethernet modules. The RIOT port for ESP8266 has been tested with the following network devices:</p>
<ul>
<li><a href="group__drivers__mrf24j40.html">mrf24j40</a> (driver for Microchip MRF24j40 based IEEE 802.15.4</li>
<li><a href="group__drivers__enc28j60.html">enc28j60</a> (driver for Microchip ENC28J60 based Ethernet modules)</li>
</ul>
<h3><a class="anchor" id="esp8266_using_mrf24j40"></a> Using MRF24J40 (module <code>mrf24j40</code>)  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>To use MRF24J40 based IEEE 802.15.4 modules as network device, the <code>mrf24j40</code> driver module has to be added to the makefile of the application:</p>
<div class="fragment"><div class="line">USEMODULE += mrf24j40</div></div><!-- fragment --><p>The <code>mrf24j40</code> driver module uses the following preconfigured interface parameters for ESP8266 boards:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Default </th><th>Remarks  </th></tr>
<tr>
<td>MRF24J40_PARAM_SPI </td><td><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>fixed, see section <a href="#esp8266_spi_interfaces">SPI Interfaces</a> </td></tr>
<tr>
<td>MRF24J40_PARAM_SPI_CLK </td><td>SPI_CLK_1MHZ </td><td>fixed </td></tr>
<tr>
<td>MRF24J40_PARAM_CS </td><td>GPIO16 </td><td>can be overridden </td></tr>
<tr>
<td>MRF24J40_PARAM_INT </td><td>GPIO0 </td><td>can be overridden </td></tr>
<tr>
<td>MRF24J40_PARAM_RESET </td><td>GPIO2 </td><td>can be overridden </td></tr>
</table>
</center><p><br />
</p>
<p>The GPIOs in this configuration can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<h3><a class="anchor" id="esp8266_using_enc28j60"></a> Using ENC28J60 (module <code>enc28j60</code>)  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>To use ENC28J60 Ethernet modules as network device, the <code>enc28j60</code> driver module has to be added to the makefile of the application:</p>
<div class="fragment"><div class="line">USEMODULE += enc28j60</div></div><!-- fragment --><p>The <code>enc28j60</code> driver module uses the following preconfigured interface parameters for ESP8266 boards:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Default </th><th>Remarks  </th></tr>
<tr>
<td>ENC28J60_PARAM_SPI </td><td><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>fixed, see section <a href="#esp8266_spi_interfaces">SPI Interfaces</a> </td></tr>
<tr>
<td>ENC28J60_PARAM_CS </td><td>GPIO4 </td><td>can be overridden </td></tr>
<tr>
<td>ENC28J60_PARAM_INT </td><td>GPIO9 </td><td>can be overridden </td></tr>
<tr>
<td>ENC28J60_PARAM_RESET </td><td>GPIO10 </td><td>can be overridden </td></tr>
</table>
</center><p>The GPIOs in this configuration can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<h2><a class="anchor" id="esp8266_sd_card_device"></a> SD-Card Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 port of RIOT is preconfigured for RIOT applications that use the <a href="group__drivers__sdcard__spi.html">SPI SD-Card driver</a>. To use SPI SD-Card driver, the <code>sdcard_spi</code> module has to be added to a makefile:</p>
<div class="fragment"><div class="line">USEMODULE += sdcard_spi</div></div><!-- fragment --><p>The <code>sdcard_spi</code> driver module uses the following preconfigured interface parameters for ESP8266 boards:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Default </th><th>Remarks  </th></tr>
<tr>
<td>SDCARD_SPI_PARAM_SPI </td><td>SPI0_DEV </td><td>fix, see section <a href="#esp8266_spi_interfaces">SPI Interfaces</a> </td></tr>
<tr>
<td>SDCARD_SPI_PARAM_CS </td><td>SPI0_CS0_GPIO </td><td>can be overridden </td></tr>
</table>
</center><p>The GPIO used as CS signal can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<p><a class="anchor" id="esp8266_app_spec_conf"></a></p><h1><a class="anchor" id="esp8266_application_specific_configurations"></a> Application-Specific Configurations  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>The board-specific configuration files <code>board.h</code> and <code>periph_conf.h</code> as well as the driver parameter configuration files <code>&lt;driver&gt;_params.h</code> define the default configurations for peripherals and device driver modules. These are, for example, the GPIOs used, bus interfaces used or available bus speeds. Because there are many possible configurations and many different application requirements, these default configurations are usually only a compromise between different requirements.</p>
<p>Therefore, it is often necessary to change some of these default configurations for individual applications. For example, while many PWM channels are needed in one application, another application does not need PWM channels, but many ADC channels.</p>
<h2><a class="anchor" id="esp8266_application_specific_board_configuration"></a> Application-Specific Board Configuration  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>To override default board configurations, simply create an application-specific board configuration file <code>$APPDIR/board.h</code> in the source directory <code>$APPDIR</code> of the application and add the definitions to be overridden. To force the preprocessor to include board's original <code>board.h</code> after that, add the <code>include_next</code> preprocessor directive as the <b>last</b> line.</p>
<p>For example to override the default definition of the GPIOs that are used as PWM channels, the application-specific board configuration file <code>$APPDIR/board.h</code> could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line"><span class="preprocessor">#define PWM0_CHANNEL_GPIOS { GPIO12, GPIO13, GPIO14, GPIO15 }</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include_next &quot;board.h&quot;</span></div></div><!-- fragment --><p>It is important to ensure that the application-specific board configuration <code>$APPDIR/board.h</code> is included first. Insert the following line as the <b>first</b> line to the application makefile <code>$APPDIR/Makefile</code>. </p><div class="fragment"><div class="line">INCLUDES += -I$(APPDIR)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To make such application-specific board configurations dependent on the ESP8266 MCU or a particular ESP8266 board, you should always enclose these definitions in the following constructs <div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line">...</div><div class="line">#endif</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef BOARD_ESP8266_ESP-12X</span></div><div class="line">...</div><div class="line">#endif</div></div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="esp8266_application_specific_driver_configuration"></a> Application-Specific Driver Configuration  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Using the approach for overriding board configurations, the parameters of drivers that are typically defined in <code>drivers/&lt;device&gt;/include/&lt;device&gt;_params.h</code> can be overridden. For that purpose just create an application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> in the source directory <code>$APPDIR</code> of the application and add the definitions to be overridden. To force the preprocessor to include driver's original <code>&lt;device&gt;_params.h</code> after that, add the <code>include_next</code> preprocessor directive as the <b>last</b> line.</p>
<p>For example, to override a GPIO used for LIS3DH sensor, the application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line"><span class="preprocessor">#define LIS3DH_PARAM_INT2           (GPIO_PIN(0, 4))</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include_next &quot;lis3dh_params.h&quot;</span></div></div><!-- fragment --><p>It is important to ensure that the application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> is included first. Insert the following line as the <b>first</b> line to the application makefile <code>$APPDIR/Makefile</code>. </p><div class="fragment"><div class="line">INCLUDES += -I$(APPDIR)</div></div><!-- fragment --><p>Pleae note:** To make such application-specific board configurations dependent on the ESP8266 MCU or a particular ESP8266 board, you should always enclose these definitions in the following constructs: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line">...</div><div class="line">#endif</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef BOARD_ESP8266_ESP-12X</span></div><div class="line">...</div><div class="line">#endif</div></div><!-- fragment --><h1><a class="anchor" id="esp8266_sdk_task_handling"></a> SDK Task Handling  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>With make command variable <code>USE_SDK=1</code>, the Espressif SDK is used. This is necessary, for example, if you want to use the built-in WLAN module. The SDK is also used automatically when software timers are used by activating the <code>esp_sw_timer</code> module.</p>
<p>Internally, the SDK uses its own priority-based multitasking sytsem, the <b>ETS</b>, to handle hardware components such as the WiFi interface, or to implement event-driven functions such as software timers. ETS periodically executes all ETS tasks with pending events in an infinite loop with the ROM function <code>ets_run</code>.</p>
<p>ETS doesn't process interrupts directly in interrupt service routines. Instead, they use the <code>ets_post</code> ROM function to send an event to one of the ETS tasks, which then processes the interrupts asynchronously. Context switches are not possible in interrupt service routines.</p>
<p>To use SDK functions and keep the system alive, ETS tasks with pending events have to be handled. For that purpose</p>
<ul>
<li>the <code>ets_task_func</code> RIOT thread with highest possible priority is used</li>
<li>the ROM functions <code>ets_run</code> and <code>ets_post</code> are overwritten.</li>
</ul>
<p>The <code>ets_task_func</code> RIOT thread is waiting for a thread flag, which is set by the <code>ets_post</code> function at the end of an ETS interrupt service routine. The flag indicates that there are ETS tasks with pending events that need to be executed. The <code>ets_task_func</code> RIOT thread then calls the <code>ets_run</code> function, which performs all ETS tasks with pending events exactly once.</p>
<p>Thus, when a hardware component used by the SDK triggers an interrupt, e.g. the WiFi interface, the interrupt sevice routine posts an event to the ETS task by calling the <code>ets_post</code> function. The overwritten version of this function sets the thread flag of the <code>ets_task_func</code> thread. The thread then calls function <code>ets_run</code> to process pending events.</p>
<dl class="section note"><dt>Note</dt><dd>Since the non-SDK version of RIOT is much smaller and faster than the SDK version, you should always compile your application without the SDK (<code>USE_SDK=0</code>, the default) if you don't need the built-in WiFi module.</dd></dl>
<h1><a class="anchor" id="esp8266_qemu_mode_and_gdb"></a> QEMU Mode and GDB  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>When QEMU mode is enabled (<code>QEMU=1</code>), instead of loading the image to the target hardware, a binary image <code>$ELFFILE.bin</code> is created in the target directory. This binary image file can be used together with QEMU to debug the code in GDB.</p>
<p>The binary image can be compiled with debugging information (<code>ENABLE_GDB=1</code> or module <code>esp_gdb</code>) or optimized without debugging information (<code>ENABLE_GDB=0</code>). The latter one is the default. The version with debugging information can be debugged in source code while the optimized version can only be debugged in assembler mode.</p>
<p>To use QEMU, you have to install QEMU for Xtensa with ESP8266 machine implementation as following.</p>
<div class="fragment"><div class="line">cd /my/source/dir</div><div class="line">git clone https:<span class="comment">//github.com/gschorcht/qemu-xtensa</span></div><div class="line">cd qemu-xtensa/</div><div class="line">git checkout xtensa-esp8266</div><div class="line">export QEMU=/path/to/esp/qemu</div><div class="line">./configure --prefix=$QEMU --target-list=xtensa-softmmu --disable-werror</div><div class="line">make</div><div class="line">make install</div></div><!-- fragment --><p>Once the compilation has been finished, QEMU for Xtensa with ESP8266 machine implementation should be available in <code>/path/to/esp/qemu/bin</code> and you can start it with</p>
<div class="fragment"><div class="line">$QEMU/bin/qemu-system-xtensa -M esp8266 -nographic -serial stdio -monitor none -s -S -kernel /path/to/the/target/image.elf.bin</div></div><!-- fragment --><p>where <code>/path/to/the/target/image.elf.bin</code> is the path to the binary image as generated by the <code>make</code> command as <code>$ELFFILE.bin</code>. After that you can start GDB in another terminal window using command:</p>
<div class="fragment"><div class="line">xtensa-lx106-elf-gdb</div></div><!-- fragment --><p>If you have compiled your binary image with debugging information, you can load the ELF file in gdb with:</p>
<div class="fragment"><div class="line">(gdb) file /path/to/the/target/image.elf</div></div><!-- fragment --><p>To start debugging, you have to connect to QEMU with command: </p><div class="fragment"><div class="line">(gdb) target remote :1234</div></div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cpu__esp8266__sdk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp8266__sdk.html">ESP8266 SDK interface</a></td></tr>
<tr class="memdesc:group__cpu__esp8266__sdk"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function declarations and mappings for compatibility with ESP8266 SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp8266__esp__wifi"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp8266__esp__wifi.html">ESP8266 WiFi netdev interface</a></td></tr>
<tr class="memdesc:group__cpu__esp8266__esp__wifi"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network device driver for the ESP8266 WiFi interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp8266__conf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp8266__conf.html">ESP8266 compile configurations</a></td></tr>
<tr class="memdesc:group__cpu__esp8266__conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time configuration macros for ESP8266 modules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:cpu_2esp8266_2include_2common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpu_2esp8266_2include_2common_8h.html">common.h</a></td></tr>
<tr class="memdesc:cpu_2esp8266_2include_2common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common helper macros. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2cpu_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2cpu_8h.html">cpu.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2cpu_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU common functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2exceptions_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2exceptions_8h.html">exceptions.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2exceptions_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">ESP8266 exception handling. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gpio__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__common_8h.html">gpio_common.h</a></td></tr>
<tr class="memdesc:gpio__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level GPIO driver implementation for ESP8266. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2irq__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2irq__arch_8h.html">irq_arch.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2irq__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the kernels irq interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2periph__cpu_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2periph__cpu_8h.html">periph_cpu.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2periph__cpu_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU specific definitions and functions for peripheral handling. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2syscalls_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2syscalls_8h.html">syscalls.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2syscalls_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of required system calls. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2thread__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2thread__arch_8h.html">thread_arch.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2thread__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the kernel's architecture dependent thread interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2tools_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2tools_8h.html">tools.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2tools_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of some tools. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:user__config_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="user__config_8h.html">user_config.h</a></td></tr>
<tr class="memdesc:user__config_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default configurations required by the SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2xtensa__conf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2xtensa__conf_8h.html">xtensa_conf.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2xtensa__conf_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xtensa ASM code specific configuration options. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu May 23 2019 18:00:21 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>

<!-- Mirrored from riot-os.org/api/group__cpu__esp8266.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 23 May 2019 16:31:51 GMT -->
</html>
